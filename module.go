package graphql

import (
	"context"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"reflect"
	"strings"

	"flamingo.me/dingo"
	"flamingo.me/flamingo/v3/framework/web"
	"github.com/99designs/gqlgen/api"
	"github.com/99designs/gqlgen/codegen/config"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/handler"
	"github.com/spf13/cobra"
)

// Service defines the bind point for graphql services
type Service interface {
	Schema() []byte
	Models() map[string]config.TypeMapEntry
}

// ModelMap is a helper to quickly create map[string]TypeMapEntry for types
type ModelMap map[string]interface{}

// Models creates the references via reflection
func (m ModelMap) Models() map[string]config.TypeMapEntry {
	res := make(map[string]config.TypeMapEntry, len(m))
	for k, v := range m {
		v := reflect.TypeOf(v)
		res[k] = config.TypeMapEntry{
			Model: []string{v.PkgPath() + "." + v.Name()},
		}
	}
	return res
}

// Module defines the graphql entry point and binds the graphql command and routes
type Module struct{}

// Configure sets up dingo
func (*Module) Configure(injector *dingo.Injector) {
	injector.BindMulti(new(cobra.Command)).ToProvider(func(
		services []Service,
	) *cobra.Command {
		return &cobra.Command{
			Use: "graphql flamingo module",
			Run: func(cmd *cobra.Command, args []string) {
				cfg := config.DefaultConfig()
				cfg.SchemaFilename = []string{"graphql/schema.graphql"}
				cfg.Models = make(map[string]config.TypeMapEntry)

				os.Mkdir("graphql", 0755)

				ioutil.WriteFile("graphql/schema.graphql", []byte(`type Query { flamingo: String }`), 0644)

				// language=go
				ioutil.WriteFile("graphql/module.go", []byte(`// Code generated by flamingo.me/graphql, DO NOT EDIT.

package graphql

import (
	"flamingo.me/dingo"
	"github.com/99designs/gqlgen/graphql"
)

type Module struct{}

func (*Module) Configure(injector *dingo.Injector) {
	injector.Bind(new(graphql.ExecutableSchema)).ToProvider(func(root *rootResolver) graphql.ExecutableSchema {
		return NewExecutableSchema(Config{Resolvers: root})
	})
}
`), 0644)

				if _, err := os.Stat("graphql/resolver.go"); os.IsNotExist(err) {
					// language=go
					ioutil.WriteFile("graphql/resolver.go", []byte(`package graphql

// this file is a starting point for the project specific resolvers
// it will not be regenerated!

type rootResolver  struct{}

var _ ResolverRoot = new(rootResolver)

func (*rootResolver) Query() QueryResolver {
	return nil
}

type queryResolver struct{}
`), 0644)
				}

				for _, service := range services {
					rt := reflect.TypeOf(service).Elem()
					fname := strings.Replace(rt.PkgPath(), "/", "_", -1) + "-" + rt.Name() + ".graphql"
					log.Println(fname)
					ioutil.WriteFile("graphql/"+fname, service.Schema(), 0644)
					cfg.SchemaFilename = append(cfg.SchemaFilename, "graphql/"+fname)

					// merge models into config models
					for k, v := range service.Models() {
						cfg.Models[k] = v
					}
				}

				cfg.Model = config.PackageConfig{Filename: "graphql/models_gen.go"}
				cfg.Exec = config.PackageConfig{Filename: "graphql/generated.go"}

				fmt.Println(api.Generate(cfg))
			},
		}
	})

	web.BindRoutes(injector, new(routes))
}

type routes struct {
	exec graphql.ExecutableSchema
}

// Inject executable schema
func (r *routes) Inject(exec graphql.ExecutableSchema) {
	r.exec = exec
}

// Routes definition for flamingo router
func (r *routes) Routes(registry *web.RouterRegistry) {
	registry.Route("/graphql", "graphql")
	registry.HandleAny("graphql", web.WrapHTTPHandler(handler.GraphQL(r.exec)))

	registry.Route("/graphql-console", "graphql.console")
	registry.HandleAny("graphql.console", web.WrapHTTPHandler(handler.Playground("Flamingo GraphQL Console", "/graphql")))
}

// FlamingoResolver example
func FlamingoResolver(_ context.Context) (*string, error) {
	flamingo := "flamingo"
	return &flamingo, nil
}
